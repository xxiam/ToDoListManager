/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example;
import java.util.HashMap;
import java.util.Optional;
import java.util.Scanner;

public class App { 

    private static String red = "\u001B[31m";
    private static String green = "\u001B[32m";
    private static String yellow = "\u001B[33m";
    private static String blue = "\u001B[34m";
    private static String purple = "\u001B[35m";
    private static String cyan = "\u001B[36m";
    private static String white = "\u001B[37m";
    private static String reset = "\u001B[0m";

    public static boolean isValidDate(String date) {
        // Check if the date is in the format YYYY-MM-DD
        if (date.equals("0")) { // 0 if no due date
            return true; 
        }
        String regex = "\\d{4}-\\d{2}-\\d{2}";
        if (!date.matches(regex)) {
            return false;
        }
        // Check if the date is valid
        String[] parts = date.split("-");
        int year = Integer.parseInt(parts[0]);
        int month = Integer.parseInt(parts[1]);
        int day = Integer.parseInt(parts[2]);
        if (month < 1 || month > 12) { // months are 1-12
            return false;
        }
        if (day < 1 || day > 31) { // days with 31 days
            return false;
        }
        if (month == 2 && day > 29) { // february
            return false; 
        }
        if ((month == 4 || month == 6 || month == 9 || month == 11) && day > 30) { // days with 30 days
            return false;
        }
        if (month == 2) { // leap year

            if (day > 29 || (day == 29 && year % 4 != 0)) {
                return false;
            }
        }
        return true;
    }

    private static void clearTerminal() {
        try {
            if (System.getProperty("os.name").toLowerCase().contains("win")) {
                new ProcessBuilder("cmd", "/c", "cls").inheritIO().start().waitFor();
            } else {
                new ProcessBuilder("clear").inheritIO().start().waitFor();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private static void printWelcomeMessage(String[] content, int highlightNumber) {
        clearTerminal();
        try {
            // Use ProcessBuilder to run the 'toilet' command with the '-f future' option
            ProcessBuilder processBuilder = new ProcessBuilder("toilet", "-f", "future", "To-Do List App");
            processBuilder.redirectErrorStream(true); // Redirect error stream to output stream
            Process process = processBuilder.start();

            // Read and print the output of the 'toilet' command
            try (Scanner scanner = new Scanner(process.getInputStream())) {
                while (scanner.hasNextLine()) {
                    System.out.println(scanner.nextLine());
                }
            }

            // print menu options
            printMenuOptions(content, highlightNumber);

            // Wait for the process to complete
            process.waitFor();
        } catch (Exception e) {
            System.out.println("To-Do List App");
        }
    }

    private static void printMenuOptions(String[] content, int highlightNumber) {
        int width = 0;

        // Calculate the maximum width of the content
        for (String line : content) {
            if (line.length() > width) {
                width = line.length();
            }
        }

        // Print the top border
        System.out.print("┌");
        for (int i = 0; i < width + 2; i++) {
            System.out.print("─");
        }
        System.out.println("┐");

        // Print the content with side borders
        for (String line : content) {
            
            if (line.contains("[ " + highlightNumber + " ]")) { // highlight the selected option
                // printf with green color
                System.out.printf("│ " + green + "%-" + width + "s" + reset + " │\n", line);
            } else {
                System.out.printf("│ %-" + width + "s │\n", line);
            }
        }

        // Print the bottom border
        System.out.print("└");
        for (int i = 0; i < width + 2; i++) {
            System.out.print("─");
        }
        System.out.println("┘");
    }

    public static void main(String[] args) {
        boolean running = true;
        ScannerMadeEasy sc = new ScannerMadeEasy();
        Handler handler = new Handler(1); // 1 for production, 0 for testing
        String[] options = {
            "[ 1 ] -> Add Entry",
            "[ 2 ] -> Edit Entry",
            "[ 3 ] -> Remove Entry",
            "[ 4 ] -> View Entry",
            "[ 5 ] -> View All Entries",
            "[ 0 ] -> Exit"
        };
        do {
            printWelcomeMessage(options, -1);
            // check if input is valid
            String prompt = "Select an option: ";
            switch (sc.readInt(prompt)) {
                case 1: // add entry
                    printWelcomeMessage(options, 1);
                    addNewEntry(handler);
                    break;
                case 2:
                    printWelcomeMessage(options, 2);
                    editEntry(handler);
                    break;
                case 3:
                    printWelcomeMessage(options, 3);
                    removeEntry(handler);
    
                    break;
                case 4:
                    printWelcomeMessage(options, 4);
                    viewEntry(handler);
                    break;
                case 5:
                    printWelcomeMessage(options, 5);
                    viewEntries(handler);
                    break;
                case 0:
                    printWelcomeMessage(options, 0);
                    running = false;
                    System.out.println("Exiting...");
                    break;
                default:
                    System.out.println("Invalid option. Please try again.");
                    break;
            }
        } while(running);
    }

    private static void viewEntry(Handler handler) {
        ScannerMadeEasy sc = new ScannerMadeEasy();
        System.out.println(red + "Viewing an entry: " + reset);

        // list all entries
        System.out.println("List of entries: ");
        HashMap<String, Entry> entryMap = handler.entryMap;
        if (entryMap.isEmpty()) {
            System.out.println(red + "There are no entries." + reset);
            return;
        } else {
            for (HashMap.Entry<String, Entry> entry : entryMap.entrySet()) {
                String[] contents = {
                    "Title: " + entry.getValue().title,
                    "Description: " + entry.getValue().description
                };
                printMenuOptions(contents, -1);
            }
        }

        String target = sc.readString("Enter title of entry to view: ");
        // get entry from handler
        Entry entry = handler.getEntry(target);
        if (entry == null) {
            System.out.println(red + "Entry not found." + reset);
            return;
        } else {
            // print entry
            String[] content = {
                "Title: " + entry.title,
                "Description: " + entry.description,
                "Priority: " + entry.priority,
                "Completed: " + entry.completed,
                "Date Created: " + entry.dateCreated,
                "Date Due: " + entry.dateDue,
                "Date Completed: " + entry.dateCompleted,
            };
            printMenuOptions(content, -1);
            String[] options = {
                "[ 1 ] -> Complete Entry",
                "[ 2 ] -> Edit Entry",
                "[ 3 ] -> Remove Entry",
                "[ 0 ] -> Back to Main Menu"
            };
            printMenuOptions(options, -1);
            int action = sc.readInt("Select an option to edit (0 to exit): ");
            switch (action) {
                case 1:
                    entry.setCompleted(true);
                    System.out.println(green + "Entry marked as completed!" + reset);
                    break;
                case 2:
                    editEntry(handler);
                    break;
                case 3:
                    removeEntry(handler);
                    break;
                case 0:
                    System.out.println(green + "Exiting view mode." + reset);
                    break;
                default:
                    System.out.println(red + "Invalid option. Please try again." + reset);
            }
        }
        sc.pauseTerminal();
    }

    private static void viewEntries(Handler handler) {
        ScannerMadeEasy sc = new ScannerMadeEasy();

        // check if there are any Entries
        if (handler.entryMap.isEmpty()) {
            System.out.println(red + "There are no entries." + reset);
            return;
        }

        String[] options = {
            "[ 1 ] -> Completed",
            "[ 2 ] -> Not Completed",
            "[ 3 ] -> Sort by Priority",
            "[ 4 ] -> Sort by Date Created",
            "[ 5 ] -> Sort by Date Due",
            "[ 0 ] -> Back to Main Menu"
        };
        printWelcomeMessage(options, -1);
        int filterType = sc.readInt("Select an option: ");
        HashMap<String, Entry> data = new HashMap<>();
        switch (filterType) {
            case 1:
                data = handler.viewAllEntries(Optional.of(1));
                break;
            case 2:
                data = handler.viewAllEntries(Optional.of(2));
                break;
            case 3:
                data = handler.viewAllEntries(Optional.of(3));
                break;
            case 4:
                data = handler.viewAllEntries(Optional.of(4));
                break;
            case 5:
                data = handler.viewAllEntries(Optional.of(5));
                break;
            case 0:
                System.out.println(green + "Exiting view mode." + reset);
                break;
            default:
                System.out.println(red + "Invalid option. Please try again." + reset);
        }
        
        // print entries
        for (HashMap.Entry<String, Entry> entry : data.entrySet()) {
            String[] content = {
                "Title: " + entry.getValue().title,
                "Description: " + entry.getValue().description,
                "Priority: " + entry.getValue().priority,
                "Completed: " + entry.getValue().completed,
                "Date Created: " + entry.getValue().dateCreated,
                "Date Due: " + entry.getValue().dateDue,
                "Date Completed: " + entry.getValue().dateCompleted,
            };
            printMenuOptions(content, -1);
        }
        sc.pauseTerminal();
    }

    private static void removeEntry(Handler handler) {
        ScannerMadeEasy sc = new ScannerMadeEasy();
        System.out.println(red + "Removing an entry: " + reset);
        HashMap<String, Entry> entryMap = handler.entryMap;
        for (Entry entry : entryMap.values()) {
            String[] content = {
                "Title: " + entry.getAsArray()[0],
                "Description: " + entry.getAsArray()[1]
            };
            printMenuOptions(content, -1);
        }

        String target = sc.readString("Enter title of entry to remove: ");
        // get entry from handler
        Entry entry;
        try {
            entry = handler.getEntry(target);
            // remove entry from handler
        } catch (IllegalArgumentException e) {
            System.out.println(red + "Entry not found." + reset);
            return;
        }

        System.out.println(red + "Are you sure you want to remove this entry? (y/n)" + reset);
        String confirm = sc.readString("Confirm: ");
        boolean validConfirm = false;
        while (!validConfirm) {
            if (confirm.equals("y") || confirm.equals("Y") || confirm.equals("n") || confirm.equals("N")) {
                validConfirm = true;
            } else {
                System.out.println(red + "Invalid input. Please enter 'y' or 'n'." + reset);
                confirm = sc.readString("Confirm: ");
            }
        }
        if (confirm.equals("y") || confirm.equals("Y")) {
            handler.removeEntry(entry.title);
            System.out.println(green + "Entry removed successfully!" + reset);
        } else if (confirm.equals("n") || confirm.equals("N")) {
            System.out.println(green + "Entry not removed." + reset);
        } else {
            System.out.println(red + "Invalid input. Please enter 'y' or 'n'." + reset);
            
        }
        sc.pauseTerminal();
    }

    private static void editEntry(Handler handler) {
        ScannerMadeEasy sc = new ScannerMadeEasy();
        System.out.println(red + "Editing an entry: " + reset);
        // list all entries
        System.out.println("List of entries: ");
        HashMap<String, Entry> entryMap = handler.entryMap;
        for (Entry entry : entryMap.values()) {
            String[] contents = {
                "Title: " + entry.getAsArray()[0],
                "Description: " + entry.getAsArray()[1],
                "Priority: " + entry.getAsArray()[2],
                "Completed: " + entry.getAsArray()[3],
                "Date Created: " + entry.getAsArray()[4],
                "Date Due: " + entry.getAsArray()[5],
                "Date Completed: " + entry.getAsArray()[6],
            };
            printMenuOptions(contents, -1);
        }
        
        String target = sc.readString("Enter title of entry to edit (or 00 to go back): ");
        // get entry from handler
        Entry entry;
        if (target.equals("00")) {
            System.out.println(green + "Exiting edit mode." + reset);
            return;
        }

        try {
            entry = handler.getEntry(target);
        } catch (IllegalArgumentException e) {
            System.out.println(red + "Entry not found." + reset);
            sc.pauseTerminal();
            return;
        }
        // print entry
        boolean stillEditing = true;
        // get new values
        do {
            clearTerminal();
            System.out.println("Editing entry: ");
            System.out.println("[1] -> Title: " + entry.title);
            System.out.println("[2] -> Description: " + entry.description);
            System.out.println("[3] -> Priority: " + entry.priority);
            System.out.println("[4] -> Date Due: " + entry.dateDue);
            System.out.println("[5] -> Completed: " + entry.completed);
            switch (sc.readInt("Select an option to edit (0 to exit): ")) {
                case 1:
                    String newTitle = sc.readString("Enter new title: ");
                    // check if title already exists
                    if (handler.getEntry(newTitle) != null) {
                        System.out.println(red + "Title already exists. Please enter a different title." + reset);
                        newTitle = sc.readString("Enter new title: ");
                    }
                    entry.setTitle(newTitle);
                    break;
                case 2:
                    String newDescription = sc.readString("Enter new description: ");
                    entry.setDescription(newDescription);
                    break;
                case 3:
                    int newPriority = sc.readInt("Enter new priority (0-10): ");
                    if (newPriority < 0 || newPriority > 10) {
                        System.out.println(red + "Invalid priority. Please enter a value between 0 and 10." + reset);
                        newPriority = sc.readInt("Enter new priority (0-10): ");
                    }
                    entry.setPriority(newPriority);
                    break;
                case 4:
                // check if date is in the future
                String currentDate = Handler.createDate();
                boolean valid = false;
                do {
                    String newDateDue = sc.readString("Enter new date due (YYYY-MM-DD) (or 0 for no due date): ");
                    if (newDateDue.equals("0")) {
                        newDateDue = null;
                        valid = true;
                    } else if (!isValidDate(newDateDue)) { // not the right format
                        System.out.println(red + "Invalid date format. Please enter a valid date (YYYY-MM-DD) (or 0 for no due date)." + reset);
                    } else if (newDateDue.compareTo(currentDate) < 0) { // if the date is in the past
                        System.out.println(red + "Due date cannot be in the past. Please enter a valid date (YYYY-MM-DD) (or 0 for no due date)." + reset);
                    } else {
                        valid = true;
                        entry.setDateDue(newDateDue);
                    }
                } while (!valid);
                break;
                case 5:
                    boolean completed = sc.readInt("Is the entry completed? (1 for yes, 0 for no): ") == 1;
                    entry.setCompleted(completed);
                    break;
                case 0:
                    stillEditing = false;
                    System.out.println(green + "Exiting edit mode." + reset);
                    // save changes
                    handler.manualSave();
                    System.out.println(green + "Changes saved successfully!" + reset);
                    sc.pauseTerminal();
                    break;
                default:
                    System.out.println(red + "Invalid option. Please try again." + reset);
            }
        } while (stillEditing);
    }

    public static void addNewEntry(Handler handler) {
        ScannerMadeEasy sc = new ScannerMadeEasy();
        // adds a new entry to the list
        System.out.println("Adding a new entry: ");
        String title = sc.readString("Enter title: ");

        // check if title already exists
        while (handler.entryMap.containsKey(title) || title.isEmpty()) {
            System.out.println(red + "Title already exists. Please enter a different title." + reset);
            title = sc.readString("Enter title: ");    
        }

        String description = sc.readString("Enter description: ");
        int priority = sc.readInt("Enter priority (0-10): ");        
        // check if priority is valid
        while (priority < 0 || priority > 10) {
            System.out.println(red + "Invalid priority. Please enter a value between 0 and 10." + reset);
            priority = sc.readInt("Enter priority (0-10): ");
        }
        
        // check if date is valid
        String currentDate = Handler.createDate();
        String dateDue;
        boolean valid = false;
        do {
            dateDue = sc.readString("Enter due date (YYYY-MM-DD) (or 0 for no due date): ");
            if (dateDue.equals("0")) {
                dateDue = null;
                valid = true;
            } else if (!isValidDate(dateDue)) { // not the right format
                System.out.println(red + "Invalid date format. Please enter a valid date (YYYY-MM-DD) (or 0 for no due date)." + reset);
            } else if (dateDue.compareTo(currentDate) < 0) { // if the date is in the past
                System.out.println(red + "Due date cannot be in the past. Please enter a valid date (YYYY-MM-DD) (or 0 for no due date)." + reset);
            } else {
                valid = true;
            }
        } while (!valid);

        // create a new entry
        handler.addEntry(title, description, priority, dateDue);
        // add the entry to the list
        System.out.println(green + "Entry added successfully!" + reset);
        sc.pauseTerminal();
    }
}